IElement
= Element
| ElementCollection

Element
= Expression()
| Program(Block body)
| Parameter(AnnotationCollection annotations, ModifierCollection modifiers, Type type, IdentifierCollection names, IExpression defaultValue, IExpression annotationExpression)
| Modifier(string name)
| GenericParameter(Type type, TypeConstrainCollection constrains, ModifierCollection modifiers)
| GenericArgument(IExpression type, ModifierCollection modifiers, TypeConstrainCollection constrains)
| Comment(string comment)
| Case(IExpression condtion, Block body)
| Argument(IExpression value, Identifier target, ModifierCollection modifiers)
| Annotation(IExpression name, ArgumentCollection arguments)
| TypeConstrain()
| PropertyDefinitionPart(AnnotationCollection annotations, ModifierCollection modifiers, Block body)
| VariableDefinition(AnnotationCollection annotations, ModifierCollection modifiers, Type type, Identifier name, IExpression initialValue, ArgumentCollection arguments, IntegerLiteral bitField, Block body)
| LinqQuery()
| OrderByKey(IExpression expression, bool ascending)
| BinaryOperator(string sign, BinaryOperatorKind kind)
| UnaryOperator(string sign, UnaryOperatorKind kind)

TypeConstrain
= ValueConstrain(Type type)
| SuperConstrain(Type type)
| ReferenceConstrain(Type type)
| ImplementsConstrain(Type type)
| ExtendConstrain(Type type)
| EigenConstrain(Type type)
| ConstructorConstrain(Type type)

ElementCollection
= AnnotationCollection(IList<Annotation> elements)
| ArgumentCollection(IList<Argument> elements)
| CaseCollection(IList <Case> elements)
| CatchCollection(IList <Catch> elements)
| ExpressionCollection(IList<Expression> elements)
| GenericArgumentCollection(IList<GenericArgument> elements)
| GenericParameterCollection(IList<GenericParameter> elements)
| IdentifierCollection(IList<Identifier> elements)
| ModifierCollection(IList<Modifier> elements)
| OrderByKeyCollection(IList<OrderByKey> elements)
| ParameterCollection(IList<Parameter> elements)
| TypeCollection(IList <Type> elements)
| TypeConstrainCollection(IList<TypeConstrain> elements)

Expression
= Call(IExpression target, ArgumentCollection args, GenericArgumentCollection genericArguments, Proc proc)
| Cast(Type type, IExpression createExpression)
| Indexer(IExpression current, ArgumentCollection create)
| KeyValue(IExpression key, IExpression value)
| Label(string name)
| New(IExpression target, ArgumentCollection arguments, GenericArgumentCollection genericArguments, ArrayLiteral initialValues, Block body)
| Property(string delimiter, IExpression owner, IExpression name)
| Slice(IExpression initializer, IExpression condition, IExpression step)
| Switch(IExpression value, CaseCollection cases)
| Catch(TypeCollection types, IExpression assign, Block body, AnnotationCollection annotations, ModifierCollection modifiers)
| If(IExpression condition, Block body, Block falseBody)
| Lambda(Identifier name, ParameterCollection parameters, Block body)
| Proc(ParameterCollection parameters, Block body)
| Try(Block body, CatchCollection catches, Block elseBody, Block finallyBody)
| ConstructorLike<TSelf>(Block body, AnnotationCollection annotations, ModifierCollection modifiers, ParameterCollection parameters, GenericParameterCollection genericParameters, TypeCollection throws)
| DoWhile(IExpression condition, Block body, Block falseBody)
| For(IExpression initializer, IExpression condition, IExpression step, Block body)
| Foreach(IExpression element, IExpression set, Block body, Block elseBody)
| While(IExpression condition, Block body, Block elseBody)
| Fix(IExpression value, Block body)
| Synchronized(IExpression value, Block body)
| Using(ExpressionCollection expressions, Block body)
| With(IExpression value, Block body)
| ComprehensionBase()
| MapComprehension(KeyValue element, ExpressionCollection generator)
| ClassLikeDefinition(AnnotationCollection annotations, ModifierCollection modifiers, IExpression name, GenericParameterCollection genericParameters, TypeConstrainCollection constrains, Block body)
| EventDefinition(AnnotationCollection annotations, ModifierCollection modifiers, Type type, Identifier name, ParameterCollection parameters, PropertyDefinitionPart adder, PropertyDefinitionPart remover)
| FunctionDefinition(AnnotationCollection annotations, ModifierCollection modifiers, Type type, GenericParameterCollection genericParameters, Identifier name, ParameterCollection parameters, TypeCollection throws, Block body, IExpression annotationExpression)
| PropertyDefinition(AnnotationCollection annotations, ModifierCollection modifiers, Type type, Identifier name, ParameterCollection parameters, PropertyDefinitionPart getter, PropertyDefinitionPart setter)
| Identifier(string name)
| Break(IExpression value)
| Continue(IExpression value)
| Goto(Identifier value)
| Redo()
| Retry()
| Return(IExpression value)
| Throw(IExpression value, IExpression data, IExpression trace)
| YieldBreak(IExpression value)
| YieldReturn(IExpression value)
| LinqExpression()
| ArrayLiteral()
| IterableLiteral()
| ListLiteral()
| MapLiteral()
| SetLiteral()
| TupleLiteral()
| Literal()
| Range(IExpression min, IExpression max)
| BinaryExpression(IExpression leftHandSide, BinaryOperator binaryOperator, IExpression rightHandSide)
| TernaryExpression(IExpression condition, IExpression trueExpression, IExpression falseExpression)
| UnaryExpression(IExpression operand, UnaryOperator unaryOperator)
| Alias(IExpression value, IExpression alias)
| Assert(IExpression value, IExpression message)
| Default(Type type)
| Defined(IExpression value)
| Delete(IExpression value)
| Exec(IExpression value)
| Import(IExpression name, string alias, IExpression member, ModifierCollection modifiers)
| Pass(IExpression value)
| Print(IExpression value)
| PrintChevron(IExpression value)
| Sizeof(IExpression expression)
| StringConversion(IExpression value)
| Typeof(IExpression type)
| Type(IExpression basicExpression)
| Block(IList<IUnifiedExpress> elements)
| VariableDefinitionList(IList<VariableDefinition> elements)

ClassLikeDefinition
= AnnotationDefinition()
| ClassDefinition()
| EigenClassDefinition()
| EnumDefinition()
| InterfaceDefinition()
| ModuleDefinition()
| NamespaceDefinition()
| StructDefinition()
| UnionDefinition()

ConstructorLike
= Constructor()
| InstanceInitializer()
| StaticInitializer()

ComprehensionBase
= IterableComprehension(IExpression element, ExpressionCollection generator)
| ListComprehension(IExpression element, ExpressionCollection generator)
| SetComprehension(IExpression element, ExpressionCollection generator)

Identifier
= LabelIdentifier(string name)
| SuperIdentifier(string name)
| ThisIdentifier(string name)
| TypeIdentifier(string name)
| VariableIdentifier(string name)
| VaueIdentifier(string name)

LinqQuery
= FromQuery(VariableIdentifier receiver, IExpression source, Type receiverType)
| GroupByQuery(IExpression element, IExpression key, VariableIdentifier receiver)
| JoinQuery(VariableIdentifier receiver, IExpression joinSource, IExpression firstEqualsKey, IExpression secondEqualsKey)
| LetQuery(VariableIdentifier variable, IExpression expression)
| OrderByQuery(OrderByKeyCollection keys)
| SelectQuery(IExpression expression, VariableIdentifier receiver)
| WhereQuery(IExpression condition)

Literal
= NullLiteral()
| TypedLiteral()

TypedLiteral
= IntegerLiteral(BigInteger value)
| BooleanLiteral(bool value)
| CharLiteral(string value)
| FractionLiteral(double value, FractionLiteralKind kind)
| RegularExpressionLiteral(string value, string options)
| StringLiteral(string value)
| SymbolLiteral(string value)

IntegerLiteral
= BigIntLiteral() | Int16Literal() | Int31Literal() | Int32Literal()
| Int64Literal() | Int8Literal() | UInt16Literal() | UInt31Literal()
| UInt32Literal() | UInt64Literal() | UInt8Literal()

Type
= BasicType()
| WrapType(Type type)

WrapType
= ArrayType() | ConstType() | GenericType() | PointerType()
| ReferenceType() | StructType() | UnionType() | VolatileType()