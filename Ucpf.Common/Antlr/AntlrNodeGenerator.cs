using System.Diagnostics.Contracts;
using System.Linq;
using System.Xml.Linq;
using Paraiba.Linq;
using Ucpf.Common.AstGenerators;
using Ucpf.Common.CodeGenerators;

namespace Ucpf.Common.Antlr {
	/// <summary>
	///   Generates a XElement object as a node of syntax tree generated by ANTLR.
	/// </summary>
	public static class AntlrNodeGenerator {
		/// <summary>
		///   Generates a XElement object as a node representing a block element.
		/// </summary>
		/// <typeparam name = "TParser">The type of syntax-tree generator.</typeparam>
		/// <param name = "node">The XElement as the node which is supplemented block.</param>
		/// <param name = "astGen"></param>
		/// <param name = "leftToken"></param>
		/// <param name = "rightToken"></param>
		/// <returns></returns>
		public static XElement GenerateBlock<TParser>(XElement node,
		                                              AntlrAstGenerator<TParser>
		                                              	astGen,
		                                              string leftToken = "{",
		                                              string rightToken = "}") {
			Contract.Requires(node != null);
			Contract.Requires(astGen != null);
			Contract.Requires(leftToken != null);
			Contract.Requires(rightToken != null);
			Contract.Ensures(Contract.Result<XElement>() != null);
			return GenerateBlock(node, astGen, DefaultCodeGenerator.Instance, leftToken,
				rightToken);
		}

		public static XElement GenerateBlock<TParser>(XElement node,
		                                              AntlrAstGenerator<TParser>
		                                              	astGen,
		                                              CodeGenerator codeGen,
		                                              string leftToken = "{",
		                                              string rightToken = "}") {
			Contract.Requires(node != null);
			Contract.Requires(astGen != null);
			Contract.Requires(codeGen != null);
			Contract.Requires(leftToken != null);
			Contract.Requires(rightToken != null);
			Contract.Ensures(Contract.Result<XElement>() != null);
			var code = codeGen.Generate(node);
			if (code.StartsWith(leftToken)) {
				return node;
			}
			var newNode = astGen.Generate(leftToken + code + rightToken,
				node.Name.LocalName);

			var oldTokenNodes = node.Descendants()
				.Where(e => e.Name.LocalName.All(char.IsUpper));
			var newTokenNodes = newNode.Descendants()
				.Where(e => e.Name.LocalName.All(char.IsUpper))
				.Skip(1);

			foreach (var t in oldTokenNodes.Zip(newTokenNodes)) {
				foreach (var attribute in t.Item1.Attributes()) {
					t.Item2.SetAttributeValue(attribute.Name, attribute.Value);
				}
			}
			return newNode;
		}

		public static XElement GenerateWrappedNode<T>(XElement node,
		                                              AntlrAstGenerator<T> astGen,
		                                              CodeGenerator codeGen,
		                                              string beforeCode,
		                                              string afterCode) {
			Contract.Requires(node != null);
			Contract.Requires(astGen != null);
			Contract.Requires(codeGen != null);
			Contract.Requires(beforeCode != null);
			Contract.Requires(afterCode != null);
			Contract.Ensures(Contract.Result<XElement>() != null);
			var oldcode = codeGen.Generate(node);
			var code = beforeCode + oldcode + afterCode;
			return astGen.Generate(code, node.Name.LocalName);
		}
	}
}